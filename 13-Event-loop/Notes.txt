The Event Loop in JavaScript
ðŸ”¹ What is the Event Loop?
The Event Loop is what enables JavaScript to handle asynchronous operations (like timers, API calls, and DOM events) efficiently, despite being single-threaded.

JavaScript uses an execution stack and task queues to manage function execution, ensuring non-blocking behavior.

ðŸ”¹ How the Event Loop Works?
JavaScript execution follows this pattern:
1ï¸âƒ£ Execute all synchronous code (call stack first)
2ï¸âƒ£ Process microtasks (Promises, queueMicrotask, MutationObserver)
3ï¸âƒ£ Process macrotasks (setTimeout, setInterval, setImmediate, I/O, UI events)
4ï¸âƒ£ Repeat the cycle

ðŸ”¹ Understanding the Call Stack
The Call Stack is a LIFO (Last In, First Out) data structure that keeps track of function calls.

code
function first() {
    console.log("First");
}
function second() {
    console.log("Second");
}
function third() {
    console.log("Third");
}

first();
second();
third();

ðŸ”¹ Output:
"First"
"Second"
"Third"


All functions execute synchronously in the Call Stack.

ðŸ”¹ Event Loop in Action
code
console.log("Start");

setTimeout(() => {
    console.log("Timeout");
}, 0);

Promise.resolve().then(() => console.log("Promise"));

console.log("End");

ðŸ”¹ Execution Flow:
1ï¸âƒ£ "Start" (Sync)
2ï¸âƒ£ "End" (Sync)
3ï¸âƒ£ "Promise" (Microtask)
4ï¸âƒ£ "Timeout" (Macrotask)

ðŸ”¹ Output:
 "Start"
 "End"
 "Promise"
 "Timeout"

 Microtasks (Promise) execute before Macrotasks (setTimeout).

ðŸ”¹ Microtasks vs Macrotasks
Task Type	Example
Microtasks	Promise.then(), MutationObserver, queueMicrotask()
Macrotasks	setTimeout(), setInterval(), setImmediate(), I/O, UI Events
ðŸ”¹ Microtasks always execute before macrotasks after the main stack is empty.

ðŸ”¹ Event Loop in Real Projects
1ï¸âƒ£ Handling API Calls Efficiently
code
fetch("https://jsonplaceholder.typicode.com/posts/1")
    .then((response) => response.json())
    .then((data) => console.log("Fetched Data:", data));

console.log("Fetching started...");

ðŸ”¹ Output:
 "Fetching started..." (Sync)
 "Fetched Data: {...}" (Async)

ðŸ’¡ The fetch() API is non-blocking. It runs in the background while JavaScript continues execution.

2ï¸âƒ£ Handling UI Events with setTimeout
code
document.querySelector("button").addEventListener("click", () => {
    setTimeout(() => {
        console.log("Button Clicked After Delay");
    }, 2000);
});
ðŸ”¹ Button click is an event â†’ setTimeout pushes the callback to the event queue.

ðŸ’¡ Avoid long synchronous tasks to keep UI responsive.

3ï¸âƒ£ Preventing UI Freezes
Problem:

code
document.querySelector("button").addEventListener("click", () => {
    for (let i = 0; i < 1000000000; i++) {} // Long sync task
    console.log("Clicked!");
});
ðŸ’¡ This blocks the UI! The event loop canâ€™t process UI updates until execution finishes.

ðŸ”¹ Solution: Use setTimeout()

code
document.querySelector("button").addEventListener("click", () => {
    setTimeout(() => console.log("Clicked!"), 0);
});
âœ… Now the UI remains responsive.