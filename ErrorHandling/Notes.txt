Error Handling in JavaScript ğŸš€
Error handling is crucial in JavaScript to ensure that unexpected issues donâ€™t break the entire application. JavaScript provides multiple ways to catch, handle, and prevent errors.

ğŸ”¹ Types of Errors in JavaScript
1ï¸âƒ£ Syntax Error â€“ Invalid code structure
Code
console.log("Hello" // Missing closing parenthesis
âœ… Fix: Close the parentheses properly.

2ï¸âƒ£ Reference Error â€“ Accessing undefined variables
Code
console.log(myVariable); // âŒ myVariable is not defined
âœ… Fix: Declare the variable before using it.

3ï¸âƒ£ Type Error â€“ Incorrect data type usage
Code
let num = 10;
num(); // âŒ TypeError: num is not a function
âœ… Fix: Ensure the correct data type is used.

ğŸ”¹ Handling Errors Using try...catch
We can catch and handle errors gracefully instead of letting them crash the application.

ğŸš€ Example: Handling an Error
Code
try {
    let result = undefinedVariable * 10;
} catch (error) {
    console.log("An error occurred:", error.message);
}
console.log("Program continues...");
âœ… Output:


An error occurred: undefinedVariable is not defined
Program continues...
âœ”ï¸ Even though an error occurs, the program does not stop execution.

ğŸ”¹ catch(error) Object Properties
Inside catch(error), the error object contains:

message â†’ Description of the error
name â†’ Error type (e.g., ReferenceError, TypeError)
stack â†’ Where the error occurred


ğŸš€ Example: Catching Error Details
Code
try {
    let num = 10;
    num.toUpperCase(); // âŒ TypeError
} catch (error) {
    console.log("Error Name:", error.name);
    console.log("Error Message:", error.message);
}
âœ… Output:

Code
Error Name: TypeError
Error Message: num.toUpperCase is not a function

ğŸ”¹ Using finally â€“ Always Executes
finally always runs whether an error occurs or not.

ğŸš€ Example: Ensuring Cleanup
Code
function processTask() {
    try {
        console.log("Processing...");
        throw new Error("Something went wrong!");
    } catch (error) {
        console.log("Error:", error.message);
    } finally {
        console.log("Cleaning up resources...");
    }
}

processTask();
âœ… Output:

Processing...
Error: Something went wrong!
Cleaning up resources...
âœ”ï¸ Use finally for cleanup tasks (e.g., closing connections, removing temporary files).

ğŸ”¹ Throwing Custom Errors
We can manually throw errors using throw.

ğŸš€ Example: Custom Error Handling
Code
function validateAge(age) {
    if (age < 18) {
        throw new Error("Age must be 18 or above.");
    }
    console.log("Valid age:", age);
}

try {
    validateAge(16);
} catch (error) {
    console.log("Validation failed:", error.message);
}
âœ… Output:


Validation failed: Age must be 18 or above.
âœ”ï¸ Use throw to reject invalid data instead of letting errors go unnoticed.

ğŸ”¹ Handling Asynchronous Errors
Errors in asynchronous functions wonâ€™t be caught by normal try...catch.

ğŸš¨ Incorrect Handling
Code
try {
    setTimeout(() => {
        throw new Error("Async error");
    }, 1000);
} catch (error) {
    console.log("Caught error:", error.message); // âŒ Won't work!
}
âœ… Fix: Use .catch() with Promises

Code
function fetchData() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            reject("Data fetch failed!");
        }, 1000);
    });
}

fetchData()
    .then((data) => console.log(data))
    .catch((error) => console.log("Caught error:", error));
âœ… Output (After 1s delay):


Caught error: Data fetch failed!
âœ”ï¸ Always use .catch() for Promises!

ğŸ”¹ Handling Errors in Async/Await
With async/await, use try...catch to handle errors properly.

ğŸš€ Example: Safe API Request
Code
async function getUserData() {
    try {
        let response = await fetch("https://invalid-url.com");
        let data = await response.json();
        console.log(data);
    } catch (error) {
        console.log("Fetch failed:", error.message);
    }
}

getUserData();
âœ… Output:


Fetch failed: Failed to fetch
âœ”ï¸ Always wrap await calls in try...catch to handle failures!

ğŸ”¹ Real-World Example â€“ Validating User Input
Code
function processUserInput(input) {
    try {
        if (!input) throw new Error("Input cannot be empty!");
        console.log("Processing input:", input);
    } catch (error) {
        console.log("Error:", error.message);
    }
}

processUserInput("");  // âŒ Throws error
processUserInput("Hello");  // âœ… Works fine
âœ… Output:


Error: Input cannot be empty!
Processing input: Hello
âœ”ï¸ Prevents invalid input from breaking the system!

ğŸ”¹ Key Takeaways
âœ”ï¸ try...catch prevents program crashes
âœ”ï¸ Use finally to clean up resources
âœ”ï¸ throw lets us create custom errors
âœ”ï¸ For async operations, use .catch() or try...catch inside async functions
âœ”ï¸ Error handling is critical in real-world applications (APIs, UI validations, database operations, etc.)